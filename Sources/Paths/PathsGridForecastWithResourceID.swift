// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

extension Paths.Grid.Forecast {
    public func resourceID(_ resourceID: String) -> WithResourceID {
        WithResourceID(path: "\(path)/\(resourceID)")
    }

    public struct WithResourceID {
        /// Path: `/grid/forecast/{resource_id}`
        public let path: String

        /// Grid Forecast Data
        public func get(parameters: GetParameters) -> Request<geosphereAustriaAPIKit.GridForecastGeoJSONSerializer> {
            Request(path: path, method: "GET", query: parameters.asQuery, id: "Grid_Forecast_Data_grid_forecast__resource_id__get")
        }

        public struct GetParameters {
            /// At least one parameter has to be specified.
            public var parameters: [String]
            /// Supply in format *south,west,north,east*
            public var bbox: String
            /// This parameter allows to access historical forecasts. If this parameter is not set the most recently created forecast is returned. If an integer value is given an older forecast is returned, where value is the 'age' of the forecast. 0 is the most recent forecast, 1 is the second to last forecast, and so on.
            public var forecastOffset: Int?
            /// Supply in format: *YYYY-MM-DDThh:mm*. Time is optional.
            public var start: Start?
            /// Supply in format: *YYYY-MM-DDThh:mm*. Time is optional.
            public var end: End?
            public var outputFormat: OutputFormat?
            /// Filename without file extension
            public var filename: String?

            /// Supply in format: *YYYY-MM-DDThh:mm*. Time is optional.
            public struct Start: Codable {
                public var string: String?
                public var date: Date?

                public init(string: String? = nil, date: Date? = nil) {
                    self.string = string
                    self.date = date
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(date, forKey: "date")
                    return encoder.items
                }
            }

            /// Supply in format: *YYYY-MM-DDThh:mm*. Time is optional.
            public struct End: Codable {
                public var string: String?
                public var date: Date?

                public init(string: String? = nil, date: Date? = nil) {
                    self.string = string
                    self.date = date
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(date, forKey: "date")
                    return encoder.items
                }
            }

            public enum OutputFormat: String, Codable, CaseIterable {
                case geojson
                case netcdf
            }

            public init(parameters: [String], bbox: String, forecastOffset: Int? = nil, start: Start? = nil, end: End? = nil, outputFormat: OutputFormat? = nil, filename: String? = nil) {
                self.parameters = parameters
                self.bbox = bbox
                self.forecastOffset = forecastOffset
                self.start = start
                self.end = end
                self.outputFormat = outputFormat
                self.filename = filename
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(parameters, forKey: "parameters")
                encoder.encode(bbox, forKey: "bbox")
                encoder.encode(forecastOffset, forKey: "forecast_offset")
                encoder.encode(start, forKey: "start")
                encoder.encode(end, forKey: "end")
                encoder.encode(outputFormat, forKey: "output_format")
                encoder.encode(filename, forKey: "filename")
                return encoder.items
            }
        }
    }
}
